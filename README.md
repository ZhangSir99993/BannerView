BannerView 广告轮播器
分析思路:
1.要实现广告轮播器首先想到用ViewPager进行展示
2.通过定时,让ViewPager进行自动切换界面实现滑动播放
3.要实现轮播效果,网上有两种方案,一种是对要加载数据列表进行处理,在列表首部加入最后一条数据,在列表的尾部加入原始数据的第一个数据,当滑动第一个或最后一个时,
  通过viewPager.setCurrentItem(i, false),进行页面切换,达到想要的效果,但是通过自己的测试发现,通过此方法会出现一个问题,当自己行主动矫正切换的时候,
  滑动效果很不流畅.网上也通过测试 onpagerSelected,onPageScrolled调用时机,来解决滑动不流畅的问题的,但总感觉有点牵强.第二种方法使用的是通过算法来
  控制放入container预加载View来实现加载循环,进而实现轮播的效果.综上所述,选择第二种方案.
  
调试过程中遇到的问题及解决方案:
1.使用第二种方法遇到一个严重的问题就是,当广告数据列表少于3个(包括3个)时,滑动过程中由于instantiateItem方法container.addView(view)的时机,
 与destroyItem方法container.removeView(view)的时机不同导致crash,由于viewPager默认预加载为三个界面当列表数也是三时,经测试,往左滑动时会先调用
 destroyItem方法,然后调用instantiateItem方法,此时没有问题可以正常滑动,但是当往右滑动时,他们的调用时机就会相反,就会报父容器已有子View,必须先移除
 的错误.为了解决这个问题我采用了一个比较简单的办法,通过对列表数据少于3个的对象预先处理:事先生成列表数据为6的新列表,再进行加载.至于为什么生成数据个数
 为6见下2.
2.当可以实现滑动轮播的时候,又发现了一个新的问题,当滑动到下一个界面时,预加载的下个界面显示的就会有一定的延时,第一个想到的解决方法是硬件加速,试着
  开启硬件加速,但是并没有发现有什么明显的改善,然后尝试着把预加载页面数量设置为2,viewPager.setOffscreenPageLimit(2);之后发现问题迎刃而解.
3.现在手动轮播已经实现,下面就来实现自动轮播,自动轮播实现后发现自动切换的时候切换效果很快,查资料发现,viewPager的切换速度是可以控制的,通过自定义
  Scroller实现速度的可控
4.自动轮播实现后发现在滑动过程中,倒计时到了之后就会自己进行滑动,然后重写dispatchTouchEvent,禁止在用户touch时进行轮播.但是发现触摸边沿位置(即:
  可视的预加载左右界面)后,拿开手指轮播就会停止,然后对边沿区域进行事件过滤.至此感觉轮播效果已经很好的实现.
  


